/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Program, ProgramError } from '@lorisleiva/js-core';

type ProgramErrorConstructor = new (
  program: Program,
  cause?: Error
) => ProgramError;
const codeToErrorMap: Map<number, ProgramErrorConstructor> = new Map();
const nameToErrorMap: Map<string, ProgramErrorConstructor> = new Map();

/**
 * InstructionUnpackError: 'Failed to unpack instruction data'
 * @category Errors
 */
class DasInstructionUnpackErrorError extends ProgramError {
  readonly name: string = 'InstructionUnpackError';
  readonly code: number = 0x0; // 0
  constructor(program: Program, cause?: Error) {
    super('Failed to unpack instruction data', program, cause);
  }
}
codeToErrorMap.set(0x0, DasInstructionUnpackErrorError);
nameToErrorMap.set('InstructionUnpackError', DasInstructionUnpackErrorError);

/**
 * InstructionPackError: 'Failed to pack instruction data'
 * @category Errors
 */
class DasInstructionPackErrorError extends ProgramError {
  readonly name: string = 'InstructionPackError';
  readonly code: number = 0x1; // 1
  constructor(program: Program, cause?: Error) {
    super('Failed to pack instruction data', program, cause);
  }
}
codeToErrorMap.set(0x1, DasInstructionPackErrorError);
nameToErrorMap.set('InstructionPackError', DasInstructionPackErrorError);

/**
 * NotRentExempt: 'Lamport balance below rent-exempt threshold'
 * @category Errors
 */
class DasNotRentExemptError extends ProgramError {
  readonly name: string = 'NotRentExempt';
  readonly code: number = 0x2; // 2
  constructor(program: Program, cause?: Error) {
    super('Lamport balance below rent-exempt threshold', program, cause);
  }
}
codeToErrorMap.set(0x2, DasNotRentExemptError);
nameToErrorMap.set('NotRentExempt', DasNotRentExemptError);

/**
 * AlreadyInitialized: 'Already initialized'
 * @category Errors
 */
class DasAlreadyInitializedError extends ProgramError {
  readonly name: string = 'AlreadyInitialized';
  readonly code: number = 0x3; // 3
  constructor(program: Program, cause?: Error) {
    super('Already initialized', program, cause);
  }
}
codeToErrorMap.set(0x3, DasAlreadyInitializedError);
nameToErrorMap.set('AlreadyInitialized', DasAlreadyInitializedError);

/**
 * Uninitialized: 'Uninitialized'
 * @category Errors
 */
class DasUninitializedError extends ProgramError {
  readonly name: string = 'Uninitialized';
  readonly code: number = 0x4; // 4
  constructor(program: Program, cause?: Error) {
    super('Uninitialized', program, cause);
  }
}
codeToErrorMap.set(0x4, DasUninitializedError);
nameToErrorMap.set('Uninitialized', DasUninitializedError);

/**
 * InvalidMetadataKey: ' Metadata's key must match seed of ['metadata', program id, mint] provided'
 * @category Errors
 */
class DasInvalidMetadataKeyError extends ProgramError {
  readonly name: string = 'InvalidMetadataKey';
  readonly code: number = 0x5; // 5
  constructor(program: Program, cause?: Error) {
    super(
      " Metadata's key must match seed of ['metadata', program id, mint] provided",
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5, DasInvalidMetadataKeyError);
nameToErrorMap.set('InvalidMetadataKey', DasInvalidMetadataKeyError);

/**
 * InvalidEditionKey: 'Edition's key must match seed of ['metadata', program id, name, 'edition'] provided'
 * @category Errors
 */
class DasInvalidEditionKeyError extends ProgramError {
  readonly name: string = 'InvalidEditionKey';
  readonly code: number = 0x6; // 6
  constructor(program: Program, cause?: Error) {
    super(
      "Edition's key must match seed of ['metadata', program id, name, 'edition'] provided",
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x6, DasInvalidEditionKeyError);
nameToErrorMap.set('InvalidEditionKey', DasInvalidEditionKeyError);

/**
 * UpdateAuthorityIncorrect: 'Update Authority given does not match'
 * @category Errors
 */
class DasUpdateAuthorityIncorrectError extends ProgramError {
  readonly name: string = 'UpdateAuthorityIncorrect';
  readonly code: number = 0x7; // 7
  constructor(program: Program, cause?: Error) {
    super('Update Authority given does not match', program, cause);
  }
}
codeToErrorMap.set(0x7, DasUpdateAuthorityIncorrectError);
nameToErrorMap.set(
  'UpdateAuthorityIncorrect',
  DasUpdateAuthorityIncorrectError
);

/**
 * UpdateAuthorityIsNotSigner: 'Update Authority needs to be signer to update metadata'
 * @category Errors
 */
class DasUpdateAuthorityIsNotSignerError extends ProgramError {
  readonly name: string = 'UpdateAuthorityIsNotSigner';
  readonly code: number = 0x8; // 8
  constructor(program: Program, cause?: Error) {
    super(
      'Update Authority needs to be signer to update metadata',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x8, DasUpdateAuthorityIsNotSignerError);
nameToErrorMap.set(
  'UpdateAuthorityIsNotSigner',
  DasUpdateAuthorityIsNotSignerError
);

/**
 * NotMintAuthority: 'You must be the mint authority and signer on this transaction'
 * @category Errors
 */
class DasNotMintAuthorityError extends ProgramError {
  readonly name: string = 'NotMintAuthority';
  readonly code: number = 0x9; // 9
  constructor(program: Program, cause?: Error) {
    super(
      'You must be the mint authority and signer on this transaction',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x9, DasNotMintAuthorityError);
nameToErrorMap.set('NotMintAuthority', DasNotMintAuthorityError);

/**
 * InvalidMintAuthority: 'Mint authority provided does not match the authority on the mint'
 * @category Errors
 */
class DasInvalidMintAuthorityError extends ProgramError {
  readonly name: string = 'InvalidMintAuthority';
  readonly code: number = 0xa; // 10
  constructor(program: Program, cause?: Error) {
    super(
      'Mint authority provided does not match the authority on the mint',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0xa, DasInvalidMintAuthorityError);
nameToErrorMap.set('InvalidMintAuthority', DasInvalidMintAuthorityError);

/**
 * NameTooLong: 'Name too long'
 * @category Errors
 */
class DasNameTooLongError extends ProgramError {
  readonly name: string = 'NameTooLong';
  readonly code: number = 0xb; // 11
  constructor(program: Program, cause?: Error) {
    super('Name too long', program, cause);
  }
}
codeToErrorMap.set(0xb, DasNameTooLongError);
nameToErrorMap.set('NameTooLong', DasNameTooLongError);

/**
 * SymbolTooLong: 'Symbol too long'
 * @category Errors
 */
class DasSymbolTooLongError extends ProgramError {
  readonly name: string = 'SymbolTooLong';
  readonly code: number = 0xc; // 12
  constructor(program: Program, cause?: Error) {
    super('Symbol too long', program, cause);
  }
}
codeToErrorMap.set(0xc, DasSymbolTooLongError);
nameToErrorMap.set('SymbolTooLong', DasSymbolTooLongError);

/**
 * UriTooLong: 'URI too long'
 * @category Errors
 */
class DasUriTooLongError extends ProgramError {
  readonly name: string = 'UriTooLong';
  readonly code: number = 0xd; // 13
  constructor(program: Program, cause?: Error) {
    super('URI too long', program, cause);
  }
}
codeToErrorMap.set(0xd, DasUriTooLongError);
nameToErrorMap.set('UriTooLong', DasUriTooLongError);

/**
 * UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner: 'Update authority must be equivalent to the metadata's authority and also signer of this transaction'
 * @category Errors
 */
class DasUpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError extends ProgramError {
  readonly name: string =
    'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner';
  readonly code: number = 0xe; // 14
  constructor(program: Program, cause?: Error) {
    super(
      "Update authority must be equivalent to the metadata's authority and also signer of this transaction",
      program,
      cause
    );
  }
}
codeToErrorMap.set(
  0xe,
  DasUpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError
);
nameToErrorMap.set(
  'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner',
  DasUpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError
);

/**
 * MintMismatch: 'Mint given does not match mint on Metadata'
 * @category Errors
 */
class DasMintMismatchError extends ProgramError {
  readonly name: string = 'MintMismatch';
  readonly code: number = 0xf; // 15
  constructor(program: Program, cause?: Error) {
    super('Mint given does not match mint on Metadata', program, cause);
  }
}
codeToErrorMap.set(0xf, DasMintMismatchError);
nameToErrorMap.set('MintMismatch', DasMintMismatchError);

/**
 * EditionsMustHaveExactlyOneToken: 'Editions must have exactly one token'
 * @category Errors
 */
class DasEditionsMustHaveExactlyOneTokenError extends ProgramError {
  readonly name: string = 'EditionsMustHaveExactlyOneToken';
  readonly code: number = 0x10; // 16
  constructor(program: Program, cause?: Error) {
    super('Editions must have exactly one token', program, cause);
  }
}
codeToErrorMap.set(0x10, DasEditionsMustHaveExactlyOneTokenError);
nameToErrorMap.set(
  'EditionsMustHaveExactlyOneToken',
  DasEditionsMustHaveExactlyOneTokenError
);

/**
 * MaxEditionsMintedAlready: 'Maximum editions printed already'
 * @category Errors
 */
class DasMaxEditionsMintedAlreadyError extends ProgramError {
  readonly name: string = 'MaxEditionsMintedAlready';
  readonly code: number = 0x11; // 17
  constructor(program: Program, cause?: Error) {
    super('Maximum editions printed already', program, cause);
  }
}
codeToErrorMap.set(0x11, DasMaxEditionsMintedAlreadyError);
nameToErrorMap.set(
  'MaxEditionsMintedAlready',
  DasMaxEditionsMintedAlreadyError
);

/**
 * TokenMintToFailed: 'Token mint to failed'
 * @category Errors
 */
class DasTokenMintToFailedError extends ProgramError {
  readonly name: string = 'TokenMintToFailed';
  readonly code: number = 0x12; // 18
  constructor(program: Program, cause?: Error) {
    super('Token mint to failed', program, cause);
  }
}
codeToErrorMap.set(0x12, DasTokenMintToFailedError);
nameToErrorMap.set('TokenMintToFailed', DasTokenMintToFailedError);

/**
 * MasterRecordMismatch: 'The master edition record passed must match the master record on the edition given'
 * @category Errors
 */
class DasMasterRecordMismatchError extends ProgramError {
  readonly name: string = 'MasterRecordMismatch';
  readonly code: number = 0x13; // 19
  constructor(program: Program, cause?: Error) {
    super(
      'The master edition record passed must match the master record on the edition given',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x13, DasMasterRecordMismatchError);
nameToErrorMap.set('MasterRecordMismatch', DasMasterRecordMismatchError);

/**
 * DestinationMintMismatch: 'The destination account does not have the right mint'
 * @category Errors
 */
class DasDestinationMintMismatchError extends ProgramError {
  readonly name: string = 'DestinationMintMismatch';
  readonly code: number = 0x14; // 20
  constructor(program: Program, cause?: Error) {
    super(
      'The destination account does not have the right mint',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x14, DasDestinationMintMismatchError);
nameToErrorMap.set('DestinationMintMismatch', DasDestinationMintMismatchError);

/**
 * EditionAlreadyMinted: 'An edition can only mint one of its kind!'
 * @category Errors
 */
class DasEditionAlreadyMintedError extends ProgramError {
  readonly name: string = 'EditionAlreadyMinted';
  readonly code: number = 0x15; // 21
  constructor(program: Program, cause?: Error) {
    super('An edition can only mint one of its kind!', program, cause);
  }
}
codeToErrorMap.set(0x15, DasEditionAlreadyMintedError);
nameToErrorMap.set('EditionAlreadyMinted', DasEditionAlreadyMintedError);

/**
 * PrintingMintDecimalsShouldBeZero: 'Printing mint decimals should be zero'
 * @category Errors
 */
class DasPrintingMintDecimalsShouldBeZeroError extends ProgramError {
  readonly name: string = 'PrintingMintDecimalsShouldBeZero';
  readonly code: number = 0x16; // 22
  constructor(program: Program, cause?: Error) {
    super('Printing mint decimals should be zero', program, cause);
  }
}
codeToErrorMap.set(0x16, DasPrintingMintDecimalsShouldBeZeroError);
nameToErrorMap.set(
  'PrintingMintDecimalsShouldBeZero',
  DasPrintingMintDecimalsShouldBeZeroError
);

/**
 * OneTimePrintingAuthorizationMintDecimalsShouldBeZero: 'OneTimePrintingAuthorization mint decimals should be zero'
 * @category Errors
 */
class DasOneTimePrintingAuthorizationMintDecimalsShouldBeZeroError extends ProgramError {
  readonly name: string =
    'OneTimePrintingAuthorizationMintDecimalsShouldBeZero';
  readonly code: number = 0x17; // 23
  constructor(program: Program, cause?: Error) {
    super(
      'OneTimePrintingAuthorization mint decimals should be zero',
      program,
      cause
    );
  }
}
codeToErrorMap.set(
  0x17,
  DasOneTimePrintingAuthorizationMintDecimalsShouldBeZeroError
);
nameToErrorMap.set(
  'OneTimePrintingAuthorizationMintDecimalsShouldBeZero',
  DasOneTimePrintingAuthorizationMintDecimalsShouldBeZeroError
);

/**
 * EditionMintDecimalsShouldBeZero: 'EditionMintDecimalsShouldBeZero'
 * @category Errors
 */
class DasEditionMintDecimalsShouldBeZeroError extends ProgramError {
  readonly name: string = 'EditionMintDecimalsShouldBeZero';
  readonly code: number = 0x18; // 24
  constructor(program: Program, cause?: Error) {
    super('EditionMintDecimalsShouldBeZero', program, cause);
  }
}
codeToErrorMap.set(0x18, DasEditionMintDecimalsShouldBeZeroError);
nameToErrorMap.set(
  'EditionMintDecimalsShouldBeZero',
  DasEditionMintDecimalsShouldBeZeroError
);

/**
 * TokenBurnFailed: 'Token burn failed'
 * @category Errors
 */
class DasTokenBurnFailedError extends ProgramError {
  readonly name: string = 'TokenBurnFailed';
  readonly code: number = 0x19; // 25
  constructor(program: Program, cause?: Error) {
    super('Token burn failed', program, cause);
  }
}
codeToErrorMap.set(0x19, DasTokenBurnFailedError);
nameToErrorMap.set('TokenBurnFailed', DasTokenBurnFailedError);

/**
 * TokenAccountOneTimeAuthMintMismatch: 'The One Time authorization mint does not match that on the token account!'
 * @category Errors
 */
class DasTokenAccountOneTimeAuthMintMismatchError extends ProgramError {
  readonly name: string = 'TokenAccountOneTimeAuthMintMismatch';
  readonly code: number = 0x1a; // 26
  constructor(program: Program, cause?: Error) {
    super(
      'The One Time authorization mint does not match that on the token account!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1a, DasTokenAccountOneTimeAuthMintMismatchError);
nameToErrorMap.set(
  'TokenAccountOneTimeAuthMintMismatch',
  DasTokenAccountOneTimeAuthMintMismatchError
);

/**
 * DerivedKeyInvalid: 'Derived key invalid'
 * @category Errors
 */
class DasDerivedKeyInvalidError extends ProgramError {
  readonly name: string = 'DerivedKeyInvalid';
  readonly code: number = 0x1b; // 27
  constructor(program: Program, cause?: Error) {
    super('Derived key invalid', program, cause);
  }
}
codeToErrorMap.set(0x1b, DasDerivedKeyInvalidError);
nameToErrorMap.set('DerivedKeyInvalid', DasDerivedKeyInvalidError);

/**
 * PrintingMintMismatch: 'The Printing mint does not match that on the master edition!'
 * @category Errors
 */
class DasPrintingMintMismatchError extends ProgramError {
  readonly name: string = 'PrintingMintMismatch';
  readonly code: number = 0x1c; // 28
  constructor(program: Program, cause?: Error) {
    super(
      'The Printing mint does not match that on the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1c, DasPrintingMintMismatchError);
nameToErrorMap.set('PrintingMintMismatch', DasPrintingMintMismatchError);

/**
 * OneTimePrintingAuthMintMismatch: 'The One Time Printing Auth mint does not match that on the master edition!'
 * @category Errors
 */
class DasOneTimePrintingAuthMintMismatchError extends ProgramError {
  readonly name: string = 'OneTimePrintingAuthMintMismatch';
  readonly code: number = 0x1d; // 29
  constructor(program: Program, cause?: Error) {
    super(
      'The One Time Printing Auth mint does not match that on the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1d, DasOneTimePrintingAuthMintMismatchError);
nameToErrorMap.set(
  'OneTimePrintingAuthMintMismatch',
  DasOneTimePrintingAuthMintMismatchError
);

/**
 * TokenAccountMintMismatch: 'The mint of the token account does not match the Printing mint!'
 * @category Errors
 */
class DasTokenAccountMintMismatchError extends ProgramError {
  readonly name: string = 'TokenAccountMintMismatch';
  readonly code: number = 0x1e; // 30
  constructor(program: Program, cause?: Error) {
    super(
      'The mint of the token account does not match the Printing mint!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1e, DasTokenAccountMintMismatchError);
nameToErrorMap.set(
  'TokenAccountMintMismatch',
  DasTokenAccountMintMismatchError
);

/**
 * TokenAccountMintMismatchV2: 'The mint of the token account does not match the master metadata mint!'
 * @category Errors
 */
class DasTokenAccountMintMismatchV2Error extends ProgramError {
  readonly name: string = 'TokenAccountMintMismatchV2';
  readonly code: number = 0x1f; // 31
  constructor(program: Program, cause?: Error) {
    super(
      'The mint of the token account does not match the master metadata mint!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1f, DasTokenAccountMintMismatchV2Error);
nameToErrorMap.set(
  'TokenAccountMintMismatchV2',
  DasTokenAccountMintMismatchV2Error
);

/**
 * NotEnoughTokens: 'Not enough tokens to mint a limited edition'
 * @category Errors
 */
class DasNotEnoughTokensError extends ProgramError {
  readonly name: string = 'NotEnoughTokens';
  readonly code: number = 0x20; // 32
  constructor(program: Program, cause?: Error) {
    super('Not enough tokens to mint a limited edition', program, cause);
  }
}
codeToErrorMap.set(0x20, DasNotEnoughTokensError);
nameToErrorMap.set('NotEnoughTokens', DasNotEnoughTokensError);

/**
 * PrintingMintAuthorizationAccountMismatch: 'The mint on your authorization token holding account does not match your Printing mint!'
 * @category Errors
 */
class DasPrintingMintAuthorizationAccountMismatchError extends ProgramError {
  readonly name: string = 'PrintingMintAuthorizationAccountMismatch';
  readonly code: number = 0x21; // 33
  constructor(program: Program, cause?: Error) {
    super(
      'The mint on your authorization token holding account does not match your Printing mint!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x21, DasPrintingMintAuthorizationAccountMismatchError);
nameToErrorMap.set(
  'PrintingMintAuthorizationAccountMismatch',
  DasPrintingMintAuthorizationAccountMismatchError
);

/**
 * AuthorizationTokenAccountOwnerMismatch: 'The authorization token account has a different owner than the update authority for the master edition!'
 * @category Errors
 */
class DasAuthorizationTokenAccountOwnerMismatchError extends ProgramError {
  readonly name: string = 'AuthorizationTokenAccountOwnerMismatch';
  readonly code: number = 0x22; // 34
  constructor(program: Program, cause?: Error) {
    super(
      'The authorization token account has a different owner than the update authority for the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x22, DasAuthorizationTokenAccountOwnerMismatchError);
nameToErrorMap.set(
  'AuthorizationTokenAccountOwnerMismatch',
  DasAuthorizationTokenAccountOwnerMismatchError
);

/**
 * Disabled: 'This feature is currently disabled.'
 * @category Errors
 */
class DasDisabledError extends ProgramError {
  readonly name: string = 'Disabled';
  readonly code: number = 0x23; // 35
  constructor(program: Program, cause?: Error) {
    super('This feature is currently disabled.', program, cause);
  }
}
codeToErrorMap.set(0x23, DasDisabledError);
nameToErrorMap.set('Disabled', DasDisabledError);

/**
 * CreatorsTooLong: 'Creators list too long'
 * @category Errors
 */
class DasCreatorsTooLongError extends ProgramError {
  readonly name: string = 'CreatorsTooLong';
  readonly code: number = 0x24; // 36
  constructor(program: Program, cause?: Error) {
    super('Creators list too long', program, cause);
  }
}
codeToErrorMap.set(0x24, DasCreatorsTooLongError);
nameToErrorMap.set('CreatorsTooLong', DasCreatorsTooLongError);

/**
 * CreatorsMustBeAtleastOne: 'Creators must be at least one if set'
 * @category Errors
 */
class DasCreatorsMustBeAtleastOneError extends ProgramError {
  readonly name: string = 'CreatorsMustBeAtleastOne';
  readonly code: number = 0x25; // 37
  constructor(program: Program, cause?: Error) {
    super('Creators must be at least one if set', program, cause);
  }
}
codeToErrorMap.set(0x25, DasCreatorsMustBeAtleastOneError);
nameToErrorMap.set(
  'CreatorsMustBeAtleastOne',
  DasCreatorsMustBeAtleastOneError
);

/**
 * MustBeOneOfCreators: 'If using a creators array, you must be one of the creators listed'
 * @category Errors
 */
class DasMustBeOneOfCreatorsError extends ProgramError {
  readonly name: string = 'MustBeOneOfCreators';
  readonly code: number = 0x26; // 38
  constructor(program: Program, cause?: Error) {
    super(
      'If using a creators array, you must be one of the creators listed',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x26, DasMustBeOneOfCreatorsError);
nameToErrorMap.set('MustBeOneOfCreators', DasMustBeOneOfCreatorsError);

/**
 * NoCreatorsPresentOnMetadata: 'This metadata does not have creators'
 * @category Errors
 */
class DasNoCreatorsPresentOnMetadataError extends ProgramError {
  readonly name: string = 'NoCreatorsPresentOnMetadata';
  readonly code: number = 0x27; // 39
  constructor(program: Program, cause?: Error) {
    super('This metadata does not have creators', program, cause);
  }
}
codeToErrorMap.set(0x27, DasNoCreatorsPresentOnMetadataError);
nameToErrorMap.set(
  'NoCreatorsPresentOnMetadata',
  DasNoCreatorsPresentOnMetadataError
);

/**
 * CreatorNotFound: 'This creator address was not found'
 * @category Errors
 */
class DasCreatorNotFoundError extends ProgramError {
  readonly name: string = 'CreatorNotFound';
  readonly code: number = 0x28; // 40
  constructor(program: Program, cause?: Error) {
    super('This creator address was not found', program, cause);
  }
}
codeToErrorMap.set(0x28, DasCreatorNotFoundError);
nameToErrorMap.set('CreatorNotFound', DasCreatorNotFoundError);

/**
 * InvalidBasisPoints: 'Basis points cannot be more than 10000'
 * @category Errors
 */
class DasInvalidBasisPointsError extends ProgramError {
  readonly name: string = 'InvalidBasisPoints';
  readonly code: number = 0x29; // 41
  constructor(program: Program, cause?: Error) {
    super('Basis points cannot be more than 10000', program, cause);
  }
}
codeToErrorMap.set(0x29, DasInvalidBasisPointsError);
nameToErrorMap.set('InvalidBasisPoints', DasInvalidBasisPointsError);

/**
 * PrimarySaleCanOnlyBeFlippedToTrue: 'Primary sale can only be flipped to true and is immutable'
 * @category Errors
 */
class DasPrimarySaleCanOnlyBeFlippedToTrueError extends ProgramError {
  readonly name: string = 'PrimarySaleCanOnlyBeFlippedToTrue';
  readonly code: number = 0x2a; // 42
  constructor(program: Program, cause?: Error) {
    super(
      'Primary sale can only be flipped to true and is immutable',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x2a, DasPrimarySaleCanOnlyBeFlippedToTrueError);
nameToErrorMap.set(
  'PrimarySaleCanOnlyBeFlippedToTrue',
  DasPrimarySaleCanOnlyBeFlippedToTrueError
);

/**
 * OwnerMismatch: 'Owner does not match that on the account given'
 * @category Errors
 */
class DasOwnerMismatchError extends ProgramError {
  readonly name: string = 'OwnerMismatch';
  readonly code: number = 0x2b; // 43
  constructor(program: Program, cause?: Error) {
    super('Owner does not match that on the account given', program, cause);
  }
}
codeToErrorMap.set(0x2b, DasOwnerMismatchError);
nameToErrorMap.set('OwnerMismatch', DasOwnerMismatchError);

/**
 * NoBalanceInAccountForAuthorization: 'This account has no tokens to be used for authorization'
 * @category Errors
 */
class DasNoBalanceInAccountForAuthorizationError extends ProgramError {
  readonly name: string = 'NoBalanceInAccountForAuthorization';
  readonly code: number = 0x2c; // 44
  constructor(program: Program, cause?: Error) {
    super(
      'This account has no tokens to be used for authorization',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x2c, DasNoBalanceInAccountForAuthorizationError);
nameToErrorMap.set(
  'NoBalanceInAccountForAuthorization',
  DasNoBalanceInAccountForAuthorizationError
);

/**
 * ShareTotalMustBe100: 'Share total must equal 100 for creator array'
 * @category Errors
 */
class DasShareTotalMustBe100Error extends ProgramError {
  readonly name: string = 'ShareTotalMustBe100';
  readonly code: number = 0x2d; // 45
  constructor(program: Program, cause?: Error) {
    super('Share total must equal 100 for creator array', program, cause);
  }
}
codeToErrorMap.set(0x2d, DasShareTotalMustBe100Error);
nameToErrorMap.set('ShareTotalMustBe100', DasShareTotalMustBe100Error);

/**
 * ReservationExists: 'This reservation list already exists!'
 * @category Errors
 */
class DasReservationExistsError extends ProgramError {
  readonly name: string = 'ReservationExists';
  readonly code: number = 0x2e; // 46
  constructor(program: Program, cause?: Error) {
    super('This reservation list already exists!', program, cause);
  }
}
codeToErrorMap.set(0x2e, DasReservationExistsError);
nameToErrorMap.set('ReservationExists', DasReservationExistsError);

/**
 * ReservationDoesNotExist: 'This reservation list does not exist!'
 * @category Errors
 */
class DasReservationDoesNotExistError extends ProgramError {
  readonly name: string = 'ReservationDoesNotExist';
  readonly code: number = 0x2f; // 47
  constructor(program: Program, cause?: Error) {
    super('This reservation list does not exist!', program, cause);
  }
}
codeToErrorMap.set(0x2f, DasReservationDoesNotExistError);
nameToErrorMap.set('ReservationDoesNotExist', DasReservationDoesNotExistError);

/**
 * ReservationNotSet: 'This reservation list exists but was never set with reservations'
 * @category Errors
 */
class DasReservationNotSetError extends ProgramError {
  readonly name: string = 'ReservationNotSet';
  readonly code: number = 0x30; // 48
  constructor(program: Program, cause?: Error) {
    super(
      'This reservation list exists but was never set with reservations',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x30, DasReservationNotSetError);
nameToErrorMap.set('ReservationNotSet', DasReservationNotSetError);

/**
 * ReservationAlreadyMade: 'This reservation list has already been set!'
 * @category Errors
 */
class DasReservationAlreadyMadeError extends ProgramError {
  readonly name: string = 'ReservationAlreadyMade';
  readonly code: number = 0x31; // 49
  constructor(program: Program, cause?: Error) {
    super('This reservation list has already been set!', program, cause);
  }
}
codeToErrorMap.set(0x31, DasReservationAlreadyMadeError);
nameToErrorMap.set('ReservationAlreadyMade', DasReservationAlreadyMadeError);

/**
 * BeyondMaxAddressSize: 'Provided more addresses than max allowed in single reservation'
 * @category Errors
 */
class DasBeyondMaxAddressSizeError extends ProgramError {
  readonly name: string = 'BeyondMaxAddressSize';
  readonly code: number = 0x32; // 50
  constructor(program: Program, cause?: Error) {
    super(
      'Provided more addresses than max allowed in single reservation',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x32, DasBeyondMaxAddressSizeError);
nameToErrorMap.set('BeyondMaxAddressSize', DasBeyondMaxAddressSizeError);

/**
 * NumericalOverflowError: 'NumericalOverflowError'
 * @category Errors
 */
class DasNumericalOverflowErrorError extends ProgramError {
  readonly name: string = 'NumericalOverflowError';
  readonly code: number = 0x33; // 51
  constructor(program: Program, cause?: Error) {
    super('NumericalOverflowError', program, cause);
  }
}
codeToErrorMap.set(0x33, DasNumericalOverflowErrorError);
nameToErrorMap.set('NumericalOverflowError', DasNumericalOverflowErrorError);

/**
 * ReservationBreachesMaximumSupply: 'This reservation would go beyond the maximum supply of the master edition!'
 * @category Errors
 */
class DasReservationBreachesMaximumSupplyError extends ProgramError {
  readonly name: string = 'ReservationBreachesMaximumSupply';
  readonly code: number = 0x34; // 52
  constructor(program: Program, cause?: Error) {
    super(
      'This reservation would go beyond the maximum supply of the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x34, DasReservationBreachesMaximumSupplyError);
nameToErrorMap.set(
  'ReservationBreachesMaximumSupply',
  DasReservationBreachesMaximumSupplyError
);

/**
 * AddressNotInReservation: 'Address not in reservation!'
 * @category Errors
 */
class DasAddressNotInReservationError extends ProgramError {
  readonly name: string = 'AddressNotInReservation';
  readonly code: number = 0x35; // 53
  constructor(program: Program, cause?: Error) {
    super('Address not in reservation!', program, cause);
  }
}
codeToErrorMap.set(0x35, DasAddressNotInReservationError);
nameToErrorMap.set('AddressNotInReservation', DasAddressNotInReservationError);

/**
 * CannotVerifyAnotherCreator: 'You cannot unilaterally verify another creator, they must sign'
 * @category Errors
 */
class DasCannotVerifyAnotherCreatorError extends ProgramError {
  readonly name: string = 'CannotVerifyAnotherCreator';
  readonly code: number = 0x36; // 54
  constructor(program: Program, cause?: Error) {
    super(
      'You cannot unilaterally verify another creator, they must sign',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x36, DasCannotVerifyAnotherCreatorError);
nameToErrorMap.set(
  'CannotVerifyAnotherCreator',
  DasCannotVerifyAnotherCreatorError
);

/**
 * CannotUnverifyAnotherCreator: 'You cannot unilaterally unverify another creator'
 * @category Errors
 */
class DasCannotUnverifyAnotherCreatorError extends ProgramError {
  readonly name: string = 'CannotUnverifyAnotherCreator';
  readonly code: number = 0x37; // 55
  constructor(program: Program, cause?: Error) {
    super('You cannot unilaterally unverify another creator', program, cause);
  }
}
codeToErrorMap.set(0x37, DasCannotUnverifyAnotherCreatorError);
nameToErrorMap.set(
  'CannotUnverifyAnotherCreator',
  DasCannotUnverifyAnotherCreatorError
);

/**
 * SpotMismatch: 'In initial reservation setting, spots remaining should equal total spots'
 * @category Errors
 */
class DasSpotMismatchError extends ProgramError {
  readonly name: string = 'SpotMismatch';
  readonly code: number = 0x38; // 56
  constructor(program: Program, cause?: Error) {
    super(
      'In initial reservation setting, spots remaining should equal total spots',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x38, DasSpotMismatchError);
nameToErrorMap.set('SpotMismatch', DasSpotMismatchError);

/**
 * IncorrectOwner: 'Incorrect account owner'
 * @category Errors
 */
class DasIncorrectOwnerError extends ProgramError {
  readonly name: string = 'IncorrectOwner';
  readonly code: number = 0x39; // 57
  constructor(program: Program, cause?: Error) {
    super('Incorrect account owner', program, cause);
  }
}
codeToErrorMap.set(0x39, DasIncorrectOwnerError);
nameToErrorMap.set('IncorrectOwner', DasIncorrectOwnerError);

/**
 * PrintingWouldBreachMaximumSupply: 'printing these tokens would breach the maximum supply limit of the master edition'
 * @category Errors
 */
class DasPrintingWouldBreachMaximumSupplyError extends ProgramError {
  readonly name: string = 'PrintingWouldBreachMaximumSupply';
  readonly code: number = 0x3a; // 58
  constructor(program: Program, cause?: Error) {
    super(
      'printing these tokens would breach the maximum supply limit of the master edition',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x3a, DasPrintingWouldBreachMaximumSupplyError);
nameToErrorMap.set(
  'PrintingWouldBreachMaximumSupply',
  DasPrintingWouldBreachMaximumSupplyError
);

/**
 * DataIsImmutable: 'Data is immutable'
 * @category Errors
 */
class DasDataIsImmutableError extends ProgramError {
  readonly name: string = 'DataIsImmutable';
  readonly code: number = 0x3b; // 59
  constructor(program: Program, cause?: Error) {
    super('Data is immutable', program, cause);
  }
}
codeToErrorMap.set(0x3b, DasDataIsImmutableError);
nameToErrorMap.set('DataIsImmutable', DasDataIsImmutableError);

/**
 * DuplicateCreatorAddress: 'No duplicate creator addresses'
 * @category Errors
 */
class DasDuplicateCreatorAddressError extends ProgramError {
  readonly name: string = 'DuplicateCreatorAddress';
  readonly code: number = 0x3c; // 60
  constructor(program: Program, cause?: Error) {
    super('No duplicate creator addresses', program, cause);
  }
}
codeToErrorMap.set(0x3c, DasDuplicateCreatorAddressError);
nameToErrorMap.set('DuplicateCreatorAddress', DasDuplicateCreatorAddressError);

/**
 * ReservationSpotsRemainingShouldMatchTotalSpotsAtStart: 'Reservation spots remaining should match total spots when first being created'
 * @category Errors
 */
class DasReservationSpotsRemainingShouldMatchTotalSpotsAtStartError extends ProgramError {
  readonly name: string =
    'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart';
  readonly code: number = 0x3d; // 61
  constructor(program: Program, cause?: Error) {
    super(
      'Reservation spots remaining should match total spots when first being created',
      program,
      cause
    );
  }
}
codeToErrorMap.set(
  0x3d,
  DasReservationSpotsRemainingShouldMatchTotalSpotsAtStartError
);
nameToErrorMap.set(
  'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart',
  DasReservationSpotsRemainingShouldMatchTotalSpotsAtStartError
);

/**
 * InvalidTokenProgram: 'Invalid token program'
 * @category Errors
 */
class DasInvalidTokenProgramError extends ProgramError {
  readonly name: string = 'InvalidTokenProgram';
  readonly code: number = 0x3e; // 62
  constructor(program: Program, cause?: Error) {
    super('Invalid token program', program, cause);
  }
}
codeToErrorMap.set(0x3e, DasInvalidTokenProgramError);
nameToErrorMap.set('InvalidTokenProgram', DasInvalidTokenProgramError);

/**
 * DataTypeMismatch: 'Data type mismatch'
 * @category Errors
 */
class DasDataTypeMismatchError extends ProgramError {
  readonly name: string = 'DataTypeMismatch';
  readonly code: number = 0x3f; // 63
  constructor(program: Program, cause?: Error) {
    super('Data type mismatch', program, cause);
  }
}
codeToErrorMap.set(0x3f, DasDataTypeMismatchError);
nameToErrorMap.set('DataTypeMismatch', DasDataTypeMismatchError);

/**
 * BeyondAlottedAddressSize: 'Beyond alotted address size in reservation!'
 * @category Errors
 */
class DasBeyondAlottedAddressSizeError extends ProgramError {
  readonly name: string = 'BeyondAlottedAddressSize';
  readonly code: number = 0x40; // 64
  constructor(program: Program, cause?: Error) {
    super('Beyond alotted address size in reservation!', program, cause);
  }
}
codeToErrorMap.set(0x40, DasBeyondAlottedAddressSizeError);
nameToErrorMap.set(
  'BeyondAlottedAddressSize',
  DasBeyondAlottedAddressSizeError
);

/**
 * ReservationNotComplete: 'The reservation has only been partially alotted'
 * @category Errors
 */
class DasReservationNotCompleteError extends ProgramError {
  readonly name: string = 'ReservationNotComplete';
  readonly code: number = 0x41; // 65
  constructor(program: Program, cause?: Error) {
    super('The reservation has only been partially alotted', program, cause);
  }
}
codeToErrorMap.set(0x41, DasReservationNotCompleteError);
nameToErrorMap.set('ReservationNotComplete', DasReservationNotCompleteError);

/**
 * TriedToReplaceAnExistingReservation: 'You cannot splice over an existing reservation!'
 * @category Errors
 */
class DasTriedToReplaceAnExistingReservationError extends ProgramError {
  readonly name: string = 'TriedToReplaceAnExistingReservation';
  readonly code: number = 0x42; // 66
  constructor(program: Program, cause?: Error) {
    super('You cannot splice over an existing reservation!', program, cause);
  }
}
codeToErrorMap.set(0x42, DasTriedToReplaceAnExistingReservationError);
nameToErrorMap.set(
  'TriedToReplaceAnExistingReservation',
  DasTriedToReplaceAnExistingReservationError
);

/**
 * InvalidOperation: 'Invalid operation'
 * @category Errors
 */
class DasInvalidOperationError extends ProgramError {
  readonly name: string = 'InvalidOperation';
  readonly code: number = 0x43; // 67
  constructor(program: Program, cause?: Error) {
    super('Invalid operation', program, cause);
  }
}
codeToErrorMap.set(0x43, DasInvalidOperationError);
nameToErrorMap.set('InvalidOperation', DasInvalidOperationError);

/**
 * InvalidOwner: 'Invalid Owner'
 * @category Errors
 */
class DasInvalidOwnerError extends ProgramError {
  readonly name: string = 'InvalidOwner';
  readonly code: number = 0x44; // 68
  constructor(program: Program, cause?: Error) {
    super('Invalid Owner', program, cause);
  }
}
codeToErrorMap.set(0x44, DasInvalidOwnerError);
nameToErrorMap.set('InvalidOwner', DasInvalidOwnerError);

/**
 * PrintingMintSupplyMustBeZeroForConversion: 'Printing mint supply must be zero for conversion'
 * @category Errors
 */
class DasPrintingMintSupplyMustBeZeroForConversionError extends ProgramError {
  readonly name: string = 'PrintingMintSupplyMustBeZeroForConversion';
  readonly code: number = 0x45; // 69
  constructor(program: Program, cause?: Error) {
    super('Printing mint supply must be zero for conversion', program, cause);
  }
}
codeToErrorMap.set(0x45, DasPrintingMintSupplyMustBeZeroForConversionError);
nameToErrorMap.set(
  'PrintingMintSupplyMustBeZeroForConversion',
  DasPrintingMintSupplyMustBeZeroForConversionError
);

/**
 * OneTimeAuthMintSupplyMustBeZeroForConversion: 'One Time Auth mint supply must be zero for conversion'
 * @category Errors
 */
class DasOneTimeAuthMintSupplyMustBeZeroForConversionError extends ProgramError {
  readonly name: string = 'OneTimeAuthMintSupplyMustBeZeroForConversion';
  readonly code: number = 0x46; // 70
  constructor(program: Program, cause?: Error) {
    super(
      'One Time Auth mint supply must be zero for conversion',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x46, DasOneTimeAuthMintSupplyMustBeZeroForConversionError);
nameToErrorMap.set(
  'OneTimeAuthMintSupplyMustBeZeroForConversion',
  DasOneTimeAuthMintSupplyMustBeZeroForConversionError
);

/**
 * InvalidEditionIndex: 'You tried to insert one edition too many into an edition mark pda'
 * @category Errors
 */
class DasInvalidEditionIndexError extends ProgramError {
  readonly name: string = 'InvalidEditionIndex';
  readonly code: number = 0x47; // 71
  constructor(program: Program, cause?: Error) {
    super(
      'You tried to insert one edition too many into an edition mark pda',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x47, DasInvalidEditionIndexError);
nameToErrorMap.set('InvalidEditionIndex', DasInvalidEditionIndexError);

/**
 * ReservationArrayShouldBeSizeOne: 'In the legacy system the reservation needs to be of size one for cpu limit reasons'
 * @category Errors
 */
class DasReservationArrayShouldBeSizeOneError extends ProgramError {
  readonly name: string = 'ReservationArrayShouldBeSizeOne';
  readonly code: number = 0x48; // 72
  constructor(program: Program, cause?: Error) {
    super(
      'In the legacy system the reservation needs to be of size one for cpu limit reasons',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x48, DasReservationArrayShouldBeSizeOneError);
nameToErrorMap.set(
  'ReservationArrayShouldBeSizeOne',
  DasReservationArrayShouldBeSizeOneError
);

/**
 * IsMutableCanOnlyBeFlippedToFalse: 'Is Mutable can only be flipped to false'
 * @category Errors
 */
class DasIsMutableCanOnlyBeFlippedToFalseError extends ProgramError {
  readonly name: string = 'IsMutableCanOnlyBeFlippedToFalse';
  readonly code: number = 0x49; // 73
  constructor(program: Program, cause?: Error) {
    super('Is Mutable can only be flipped to false', program, cause);
  }
}
codeToErrorMap.set(0x49, DasIsMutableCanOnlyBeFlippedToFalseError);
nameToErrorMap.set(
  'IsMutableCanOnlyBeFlippedToFalse',
  DasIsMutableCanOnlyBeFlippedToFalseError
);

/**
 * CollectionCannotBeVerifiedInThisInstruction: 'Collection cannot be verified in this instruction'
 * @category Errors
 */
class DasCollectionCannotBeVerifiedInThisInstructionError extends ProgramError {
  readonly name: string = 'CollectionCannotBeVerifiedInThisInstruction';
  readonly code: number = 0x4a; // 74
  constructor(program: Program, cause?: Error) {
    super('Collection cannot be verified in this instruction', program, cause);
  }
}
codeToErrorMap.set(0x4a, DasCollectionCannotBeVerifiedInThisInstructionError);
nameToErrorMap.set(
  'CollectionCannotBeVerifiedInThisInstruction',
  DasCollectionCannotBeVerifiedInThisInstructionError
);

/**
 * Removed: 'This instruction was deprecated in a previous release and is now removed'
 * @category Errors
 */
class DasRemovedError extends ProgramError {
  readonly name: string = 'Removed';
  readonly code: number = 0x4b; // 75
  constructor(program: Program, cause?: Error) {
    super(
      'This instruction was deprecated in a previous release and is now removed',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x4b, DasRemovedError);
nameToErrorMap.set('Removed', DasRemovedError);

/**
 * MustBeBurned: 'This token use method is burn and there are no remaining uses, it must be burned'
 * @category Errors
 */
class DasMustBeBurnedError extends ProgramError {
  readonly name: string = 'MustBeBurned';
  readonly code: number = 0x4c; // 76
  constructor(program: Program, cause?: Error) {
    super(
      'This token use method is burn and there are no remaining uses, it must be burned',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x4c, DasMustBeBurnedError);
nameToErrorMap.set('MustBeBurned', DasMustBeBurnedError);

/**
 * InvalidUseMethod: 'This use method is invalid'
 * @category Errors
 */
class DasInvalidUseMethodError extends ProgramError {
  readonly name: string = 'InvalidUseMethod';
  readonly code: number = 0x4d; // 77
  constructor(program: Program, cause?: Error) {
    super('This use method is invalid', program, cause);
  }
}
codeToErrorMap.set(0x4d, DasInvalidUseMethodError);
nameToErrorMap.set('InvalidUseMethod', DasInvalidUseMethodError);

/**
 * CannotChangeUseMethodAfterFirstUse: 'Cannot Change Use Method after the first use'
 * @category Errors
 */
class DasCannotChangeUseMethodAfterFirstUseError extends ProgramError {
  readonly name: string = 'CannotChangeUseMethodAfterFirstUse';
  readonly code: number = 0x4e; // 78
  constructor(program: Program, cause?: Error) {
    super('Cannot Change Use Method after the first use', program, cause);
  }
}
codeToErrorMap.set(0x4e, DasCannotChangeUseMethodAfterFirstUseError);
nameToErrorMap.set(
  'CannotChangeUseMethodAfterFirstUse',
  DasCannotChangeUseMethodAfterFirstUseError
);

/**
 * CannotChangeUsesAfterFirstUse: 'Cannot Change Remaining or Available uses after the first use'
 * @category Errors
 */
class DasCannotChangeUsesAfterFirstUseError extends ProgramError {
  readonly name: string = 'CannotChangeUsesAfterFirstUse';
  readonly code: number = 0x4f; // 79
  constructor(program: Program, cause?: Error) {
    super(
      'Cannot Change Remaining or Available uses after the first use',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x4f, DasCannotChangeUsesAfterFirstUseError);
nameToErrorMap.set(
  'CannotChangeUsesAfterFirstUse',
  DasCannotChangeUsesAfterFirstUseError
);

/**
 * CollectionNotFound: 'Collection Not Found on Metadata'
 * @category Errors
 */
class DasCollectionNotFoundError extends ProgramError {
  readonly name: string = 'CollectionNotFound';
  readonly code: number = 0x50; // 80
  constructor(program: Program, cause?: Error) {
    super('Collection Not Found on Metadata', program, cause);
  }
}
codeToErrorMap.set(0x50, DasCollectionNotFoundError);
nameToErrorMap.set('CollectionNotFound', DasCollectionNotFoundError);

/**
 * InvalidCollectionUpdateAuthority: 'Collection Update Authority is invalid'
 * @category Errors
 */
class DasInvalidCollectionUpdateAuthorityError extends ProgramError {
  readonly name: string = 'InvalidCollectionUpdateAuthority';
  readonly code: number = 0x51; // 81
  constructor(program: Program, cause?: Error) {
    super('Collection Update Authority is invalid', program, cause);
  }
}
codeToErrorMap.set(0x51, DasInvalidCollectionUpdateAuthorityError);
nameToErrorMap.set(
  'InvalidCollectionUpdateAuthority',
  DasInvalidCollectionUpdateAuthorityError
);

/**
 * CollectionMustBeAUniqueMasterEdition: 'Collection Must Be a Unique Master Edition v2'
 * @category Errors
 */
class DasCollectionMustBeAUniqueMasterEditionError extends ProgramError {
  readonly name: string = 'CollectionMustBeAUniqueMasterEdition';
  readonly code: number = 0x52; // 82
  constructor(program: Program, cause?: Error) {
    super('Collection Must Be a Unique Master Edition v2', program, cause);
  }
}
codeToErrorMap.set(0x52, DasCollectionMustBeAUniqueMasterEditionError);
nameToErrorMap.set(
  'CollectionMustBeAUniqueMasterEdition',
  DasCollectionMustBeAUniqueMasterEditionError
);

/**
 * UseAuthorityRecordAlreadyExists: 'The Use Authority Record Already Exists, to modify it Revoke, then Approve'
 * @category Errors
 */
class DasUseAuthorityRecordAlreadyExistsError extends ProgramError {
  readonly name: string = 'UseAuthorityRecordAlreadyExists';
  readonly code: number = 0x53; // 83
  constructor(program: Program, cause?: Error) {
    super(
      'The Use Authority Record Already Exists, to modify it Revoke, then Approve',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x53, DasUseAuthorityRecordAlreadyExistsError);
nameToErrorMap.set(
  'UseAuthorityRecordAlreadyExists',
  DasUseAuthorityRecordAlreadyExistsError
);

/**
 * UseAuthorityRecordAlreadyRevoked: 'The Use Authority Record is empty or already revoked'
 * @category Errors
 */
class DasUseAuthorityRecordAlreadyRevokedError extends ProgramError {
  readonly name: string = 'UseAuthorityRecordAlreadyRevoked';
  readonly code: number = 0x54; // 84
  constructor(program: Program, cause?: Error) {
    super(
      'The Use Authority Record is empty or already revoked',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x54, DasUseAuthorityRecordAlreadyRevokedError);
nameToErrorMap.set(
  'UseAuthorityRecordAlreadyRevoked',
  DasUseAuthorityRecordAlreadyRevokedError
);

/**
 * Unusable: 'This token has no uses'
 * @category Errors
 */
class DasUnusableError extends ProgramError {
  readonly name: string = 'Unusable';
  readonly code: number = 0x55; // 85
  constructor(program: Program, cause?: Error) {
    super('This token has no uses', program, cause);
  }
}
codeToErrorMap.set(0x55, DasUnusableError);
nameToErrorMap.set('Unusable', DasUnusableError);

/**
 * NotEnoughUses: 'There are not enough Uses left on this token.'
 * @category Errors
 */
class DasNotEnoughUsesError extends ProgramError {
  readonly name: string = 'NotEnoughUses';
  readonly code: number = 0x56; // 86
  constructor(program: Program, cause?: Error) {
    super('There are not enough Uses left on this token.', program, cause);
  }
}
codeToErrorMap.set(0x56, DasNotEnoughUsesError);
nameToErrorMap.set('NotEnoughUses', DasNotEnoughUsesError);

/**
 * CollectionAuthorityRecordAlreadyExists: 'This Collection Authority Record Already Exists.'
 * @category Errors
 */
class DasCollectionAuthorityRecordAlreadyExistsError extends ProgramError {
  readonly name: string = 'CollectionAuthorityRecordAlreadyExists';
  readonly code: number = 0x57; // 87
  constructor(program: Program, cause?: Error) {
    super('This Collection Authority Record Already Exists.', program, cause);
  }
}
codeToErrorMap.set(0x57, DasCollectionAuthorityRecordAlreadyExistsError);
nameToErrorMap.set(
  'CollectionAuthorityRecordAlreadyExists',
  DasCollectionAuthorityRecordAlreadyExistsError
);

/**
 * CollectionAuthorityDoesNotExist: 'This Collection Authority Record Does Not Exist.'
 * @category Errors
 */
class DasCollectionAuthorityDoesNotExistError extends ProgramError {
  readonly name: string = 'CollectionAuthorityDoesNotExist';
  readonly code: number = 0x58; // 88
  constructor(program: Program, cause?: Error) {
    super('This Collection Authority Record Does Not Exist.', program, cause);
  }
}
codeToErrorMap.set(0x58, DasCollectionAuthorityDoesNotExistError);
nameToErrorMap.set(
  'CollectionAuthorityDoesNotExist',
  DasCollectionAuthorityDoesNotExistError
);

/**
 * InvalidUseAuthorityRecord: 'This Use Authority Record is invalid.'
 * @category Errors
 */
class DasInvalidUseAuthorityRecordError extends ProgramError {
  readonly name: string = 'InvalidUseAuthorityRecord';
  readonly code: number = 0x59; // 89
  constructor(program: Program, cause?: Error) {
    super('This Use Authority Record is invalid.', program, cause);
  }
}
codeToErrorMap.set(0x59, DasInvalidUseAuthorityRecordError);
nameToErrorMap.set(
  'InvalidUseAuthorityRecord',
  DasInvalidUseAuthorityRecordError
);

/**
 * InvalidCollectionAuthorityRecord: 'This Collection Authority Record is invalid.'
 * @category Errors
 */
class DasInvalidCollectionAuthorityRecordError extends ProgramError {
  readonly name: string = 'InvalidCollectionAuthorityRecord';
  readonly code: number = 0x5a; // 90
  constructor(program: Program, cause?: Error) {
    super('This Collection Authority Record is invalid.', program, cause);
  }
}
codeToErrorMap.set(0x5a, DasInvalidCollectionAuthorityRecordError);
nameToErrorMap.set(
  'InvalidCollectionAuthorityRecord',
  DasInvalidCollectionAuthorityRecordError
);

/**
 * InvalidFreezeAuthority: 'Metadata does not match the freeze authority on the mint'
 * @category Errors
 */
class DasInvalidFreezeAuthorityError extends ProgramError {
  readonly name: string = 'InvalidFreezeAuthority';
  readonly code: number = 0x5b; // 91
  constructor(program: Program, cause?: Error) {
    super(
      'Metadata does not match the freeze authority on the mint',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5b, DasInvalidFreezeAuthorityError);
nameToErrorMap.set('InvalidFreezeAuthority', DasInvalidFreezeAuthorityError);

/**
 * InvalidDelegate: 'All tokens in this account have not been delegated to this user.'
 * @category Errors
 */
class DasInvalidDelegateError extends ProgramError {
  readonly name: string = 'InvalidDelegate';
  readonly code: number = 0x5c; // 92
  constructor(program: Program, cause?: Error) {
    super(
      'All tokens in this account have not been delegated to this user.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5c, DasInvalidDelegateError);
nameToErrorMap.set('InvalidDelegate', DasInvalidDelegateError);

/**
 * CannotAdjustVerifiedCreator: 'Creator can not be adjusted once they are verified.'
 * @category Errors
 */
class DasCannotAdjustVerifiedCreatorError extends ProgramError {
  readonly name: string = 'CannotAdjustVerifiedCreator';
  readonly code: number = 0x5d; // 93
  constructor(program: Program, cause?: Error) {
    super(
      'Creator can not be adjusted once they are verified.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5d, DasCannotAdjustVerifiedCreatorError);
nameToErrorMap.set(
  'CannotAdjustVerifiedCreator',
  DasCannotAdjustVerifiedCreatorError
);

/**
 * CannotRemoveVerifiedCreator: 'Verified creators cannot be removed.'
 * @category Errors
 */
class DasCannotRemoveVerifiedCreatorError extends ProgramError {
  readonly name: string = 'CannotRemoveVerifiedCreator';
  readonly code: number = 0x5e; // 94
  constructor(program: Program, cause?: Error) {
    super('Verified creators cannot be removed.', program, cause);
  }
}
codeToErrorMap.set(0x5e, DasCannotRemoveVerifiedCreatorError);
nameToErrorMap.set(
  'CannotRemoveVerifiedCreator',
  DasCannotRemoveVerifiedCreatorError
);

/**
 * CannotWipeVerifiedCreators: 'Can not wipe verified creators.'
 * @category Errors
 */
class DasCannotWipeVerifiedCreatorsError extends ProgramError {
  readonly name: string = 'CannotWipeVerifiedCreators';
  readonly code: number = 0x5f; // 95
  constructor(program: Program, cause?: Error) {
    super('Can not wipe verified creators.', program, cause);
  }
}
codeToErrorMap.set(0x5f, DasCannotWipeVerifiedCreatorsError);
nameToErrorMap.set(
  'CannotWipeVerifiedCreators',
  DasCannotWipeVerifiedCreatorsError
);

/**
 * NotAllowedToChangeSellerFeeBasisPoints: 'Not allowed to change seller fee basis points.'
 * @category Errors
 */
class DasNotAllowedToChangeSellerFeeBasisPointsError extends ProgramError {
  readonly name: string = 'NotAllowedToChangeSellerFeeBasisPoints';
  readonly code: number = 0x60; // 96
  constructor(program: Program, cause?: Error) {
    super('Not allowed to change seller fee basis points.', program, cause);
  }
}
codeToErrorMap.set(0x60, DasNotAllowedToChangeSellerFeeBasisPointsError);
nameToErrorMap.set(
  'NotAllowedToChangeSellerFeeBasisPoints',
  DasNotAllowedToChangeSellerFeeBasisPointsError
);

/**
 * EditionOverrideCannotBeZero: 'Edition override cannot be zero'
 * @category Errors
 */
class DasEditionOverrideCannotBeZeroError extends ProgramError {
  readonly name: string = 'EditionOverrideCannotBeZero';
  readonly code: number = 0x61; // 97
  constructor(program: Program, cause?: Error) {
    super('Edition override cannot be zero', program, cause);
  }
}
codeToErrorMap.set(0x61, DasEditionOverrideCannotBeZeroError);
nameToErrorMap.set(
  'EditionOverrideCannotBeZero',
  DasEditionOverrideCannotBeZeroError
);

/**
 * InvalidUser: 'Invalid User'
 * @category Errors
 */
class DasInvalidUserError extends ProgramError {
  readonly name: string = 'InvalidUser';
  readonly code: number = 0x62; // 98
  constructor(program: Program, cause?: Error) {
    super('Invalid User', program, cause);
  }
}
codeToErrorMap.set(0x62, DasInvalidUserError);
nameToErrorMap.set('InvalidUser', DasInvalidUserError);

/**
 * RevokeCollectionAuthoritySignerIncorrect: 'Revoke Collection Authority signer is incorrect'
 * @category Errors
 */
class DasRevokeCollectionAuthoritySignerIncorrectError extends ProgramError {
  readonly name: string = 'RevokeCollectionAuthoritySignerIncorrect';
  readonly code: number = 0x63; // 99
  constructor(program: Program, cause?: Error) {
    super('Revoke Collection Authority signer is incorrect', program, cause);
  }
}
codeToErrorMap.set(0x63, DasRevokeCollectionAuthoritySignerIncorrectError);
nameToErrorMap.set(
  'RevokeCollectionAuthoritySignerIncorrect',
  DasRevokeCollectionAuthoritySignerIncorrectError
);

/**
 * TokenCloseFailed: 'Token close failed'
 * @category Errors
 */
class DasTokenCloseFailedError extends ProgramError {
  readonly name: string = 'TokenCloseFailed';
  readonly code: number = 0x64; // 100
  constructor(program: Program, cause?: Error) {
    super('Token close failed', program, cause);
  }
}
codeToErrorMap.set(0x64, DasTokenCloseFailedError);
nameToErrorMap.set('TokenCloseFailed', DasTokenCloseFailedError);

/**
 * UnsizedCollection: 'Can't use this function on unsized collection'
 * @category Errors
 */
class DasUnsizedCollectionError extends ProgramError {
  readonly name: string = 'UnsizedCollection';
  readonly code: number = 0x65; // 101
  constructor(program: Program, cause?: Error) {
    super("Can't use this function on unsized collection", program, cause);
  }
}
codeToErrorMap.set(0x65, DasUnsizedCollectionError);
nameToErrorMap.set('UnsizedCollection', DasUnsizedCollectionError);

/**
 * SizedCollection: 'Can't use this function on a sized collection'
 * @category Errors
 */
class DasSizedCollectionError extends ProgramError {
  readonly name: string = 'SizedCollection';
  readonly code: number = 0x66; // 102
  constructor(program: Program, cause?: Error) {
    super("Can't use this function on a sized collection", program, cause);
  }
}
codeToErrorMap.set(0x66, DasSizedCollectionError);
nameToErrorMap.set('SizedCollection', DasSizedCollectionError);

/**
 * MissingCollectionMetadata: 'Can't burn a verified member of a collection w/o providing collection metadata account'
 * @category Errors
 */
class DasMissingCollectionMetadataError extends ProgramError {
  readonly name: string = 'MissingCollectionMetadata';
  readonly code: number = 0x67; // 103
  constructor(program: Program, cause?: Error) {
    super(
      "Can't burn a verified member of a collection w/o providing collection metadata account",
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x67, DasMissingCollectionMetadataError);
nameToErrorMap.set(
  'MissingCollectionMetadata',
  DasMissingCollectionMetadataError
);

/**
 * NotAMemberOfCollection: 'This NFT is not a member of the specified collection.'
 * @category Errors
 */
class DasNotAMemberOfCollectionError extends ProgramError {
  readonly name: string = 'NotAMemberOfCollection';
  readonly code: number = 0x68; // 104
  constructor(program: Program, cause?: Error) {
    super(
      'This NFT is not a member of the specified collection.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x68, DasNotAMemberOfCollectionError);
nameToErrorMap.set('NotAMemberOfCollection', DasNotAMemberOfCollectionError);

/**
 * NotVerifiedMemberOfCollection: 'This NFT is not a verified member of the specified collection.'
 * @category Errors
 */
class DasNotVerifiedMemberOfCollectionError extends ProgramError {
  readonly name: string = 'NotVerifiedMemberOfCollection';
  readonly code: number = 0x69; // 105
  constructor(program: Program, cause?: Error) {
    super(
      'This NFT is not a verified member of the specified collection.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x69, DasNotVerifiedMemberOfCollectionError);
nameToErrorMap.set(
  'NotVerifiedMemberOfCollection',
  DasNotVerifiedMemberOfCollectionError
);

/**
 * NotACollectionParent: 'This NFT is not a collection parent NFT.'
 * @category Errors
 */
class DasNotACollectionParentError extends ProgramError {
  readonly name: string = 'NotACollectionParent';
  readonly code: number = 0x6a; // 106
  constructor(program: Program, cause?: Error) {
    super('This NFT is not a collection parent NFT.', program, cause);
  }
}
codeToErrorMap.set(0x6a, DasNotACollectionParentError);
nameToErrorMap.set('NotACollectionParent', DasNotACollectionParentError);

/**
 * CouldNotDetermineTokenStandard: 'Could not determine a TokenStandard type.'
 * @category Errors
 */
class DasCouldNotDetermineTokenStandardError extends ProgramError {
  readonly name: string = 'CouldNotDetermineTokenStandard';
  readonly code: number = 0x6b; // 107
  constructor(program: Program, cause?: Error) {
    super('Could not determine a TokenStandard type.', program, cause);
  }
}
codeToErrorMap.set(0x6b, DasCouldNotDetermineTokenStandardError);
nameToErrorMap.set(
  'CouldNotDetermineTokenStandard',
  DasCouldNotDetermineTokenStandardError
);

/**
 * MissingEditionAccount: 'This mint account has an edition but none was provided.'
 * @category Errors
 */
class DasMissingEditionAccountError extends ProgramError {
  readonly name: string = 'MissingEditionAccount';
  readonly code: number = 0x6c; // 108
  constructor(program: Program, cause?: Error) {
    super(
      'This mint account has an edition but none was provided.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x6c, DasMissingEditionAccountError);
nameToErrorMap.set('MissingEditionAccount', DasMissingEditionAccountError);

/**
 * NotAMasterEdition: 'This edition is not a Master Edition'
 * @category Errors
 */
class DasNotAMasterEditionError extends ProgramError {
  readonly name: string = 'NotAMasterEdition';
  readonly code: number = 0x6d; // 109
  constructor(program: Program, cause?: Error) {
    super('This edition is not a Master Edition', program, cause);
  }
}
codeToErrorMap.set(0x6d, DasNotAMasterEditionError);
nameToErrorMap.set('NotAMasterEdition', DasNotAMasterEditionError);

/**
 * MasterEditionHasPrints: 'This Master Edition has existing prints'
 * @category Errors
 */
class DasMasterEditionHasPrintsError extends ProgramError {
  readonly name: string = 'MasterEditionHasPrints';
  readonly code: number = 0x6e; // 110
  constructor(program: Program, cause?: Error) {
    super('This Master Edition has existing prints', program, cause);
  }
}
codeToErrorMap.set(0x6e, DasMasterEditionHasPrintsError);
nameToErrorMap.set('MasterEditionHasPrints', DasMasterEditionHasPrintsError);

/**
 * BorshDeserializationError: 'Borsh Deserialization Error'
 * @category Errors
 */
class DasBorshDeserializationErrorError extends ProgramError {
  readonly name: string = 'BorshDeserializationError';
  readonly code: number = 0x6f; // 111
  constructor(program: Program, cause?: Error) {
    super('Borsh Deserialization Error', program, cause);
  }
}
codeToErrorMap.set(0x6f, DasBorshDeserializationErrorError);
nameToErrorMap.set(
  'BorshDeserializationError',
  DasBorshDeserializationErrorError
);

/**
 * CannotUpdateVerifiedCollection: 'Cannot update a verified collection in this command'
 * @category Errors
 */
class DasCannotUpdateVerifiedCollectionError extends ProgramError {
  readonly name: string = 'CannotUpdateVerifiedCollection';
  readonly code: number = 0x70; // 112
  constructor(program: Program, cause?: Error) {
    super(
      'Cannot update a verified collection in this command',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x70, DasCannotUpdateVerifiedCollectionError);
nameToErrorMap.set(
  'CannotUpdateVerifiedCollection',
  DasCannotUpdateVerifiedCollectionError
);

/**
 * CollectionMasterEditionAccountInvalid: 'Edition account doesnt match collection '
 * @category Errors
 */
class DasCollectionMasterEditionAccountInvalidError extends ProgramError {
  readonly name: string = 'CollectionMasterEditionAccountInvalid';
  readonly code: number = 0x71; // 113
  constructor(program: Program, cause?: Error) {
    super('Edition account doesnt match collection ', program, cause);
  }
}
codeToErrorMap.set(0x71, DasCollectionMasterEditionAccountInvalidError);
nameToErrorMap.set(
  'CollectionMasterEditionAccountInvalid',
  DasCollectionMasterEditionAccountInvalidError
);

/**
 * AlreadyVerified: 'Item is already verified.'
 * @category Errors
 */
class DasAlreadyVerifiedError extends ProgramError {
  readonly name: string = 'AlreadyVerified';
  readonly code: number = 0x72; // 114
  constructor(program: Program, cause?: Error) {
    super('Item is already verified.', program, cause);
  }
}
codeToErrorMap.set(0x72, DasAlreadyVerifiedError);
nameToErrorMap.set('AlreadyVerified', DasAlreadyVerifiedError);

/**
 * AlreadyUnverified: 'Item is already unverified.'
 * @category Errors
 */
class DasAlreadyUnverifiedError extends ProgramError {
  readonly name: string = 'AlreadyUnverified';
  readonly code: number = 0x73; // 115
  constructor(program: Program, cause?: Error) {
    super('Item is already unverified.', program, cause);
  }
}
codeToErrorMap.set(0x73, DasAlreadyUnverifiedError);
nameToErrorMap.set('AlreadyUnverified', DasAlreadyUnverifiedError);

/**
 * NotAPrintEdition: 'This edition is not a Print Edition'
 * @category Errors
 */
class DasNotAPrintEditionError extends ProgramError {
  readonly name: string = 'NotAPrintEdition';
  readonly code: number = 0x74; // 116
  constructor(program: Program, cause?: Error) {
    super('This edition is not a Print Edition', program, cause);
  }
}
codeToErrorMap.set(0x74, DasNotAPrintEditionError);
nameToErrorMap.set('NotAPrintEdition', DasNotAPrintEditionError);

/**
 * InvalidMasterEdition: 'Invalid Master Edition'
 * @category Errors
 */
class DasInvalidMasterEditionError extends ProgramError {
  readonly name: string = 'InvalidMasterEdition';
  readonly code: number = 0x75; // 117
  constructor(program: Program, cause?: Error) {
    super('Invalid Master Edition', program, cause);
  }
}
codeToErrorMap.set(0x75, DasInvalidMasterEditionError);
nameToErrorMap.set('InvalidMasterEdition', DasInvalidMasterEditionError);

/**
 * InvalidPrintEdition: 'Invalid Print Edition'
 * @category Errors
 */
class DasInvalidPrintEditionError extends ProgramError {
  readonly name: string = 'InvalidPrintEdition';
  readonly code: number = 0x76; // 118
  constructor(program: Program, cause?: Error) {
    super('Invalid Print Edition', program, cause);
  }
}
codeToErrorMap.set(0x76, DasInvalidPrintEditionError);
nameToErrorMap.set('InvalidPrintEdition', DasInvalidPrintEditionError);

/**
 * InvalidEditionMarker: 'Invalid Edition Marker'
 * @category Errors
 */
class DasInvalidEditionMarkerError extends ProgramError {
  readonly name: string = 'InvalidEditionMarker';
  readonly code: number = 0x77; // 119
  constructor(program: Program, cause?: Error) {
    super('Invalid Edition Marker', program, cause);
  }
}
codeToErrorMap.set(0x77, DasInvalidEditionMarkerError);
nameToErrorMap.set('InvalidEditionMarker', DasInvalidEditionMarkerError);

/**
 * ReservationListDeprecated: 'Reservation List is Deprecated'
 * @category Errors
 */
class DasReservationListDeprecatedError extends ProgramError {
  readonly name: string = 'ReservationListDeprecated';
  readonly code: number = 0x78; // 120
  constructor(program: Program, cause?: Error) {
    super('Reservation List is Deprecated', program, cause);
  }
}
codeToErrorMap.set(0x78, DasReservationListDeprecatedError);
nameToErrorMap.set(
  'ReservationListDeprecated',
  DasReservationListDeprecatedError
);

/**
 * PrintEditionDoesNotMatchMasterEdition: 'Print Edition does not match Master Edition'
 * @category Errors
 */
class DasPrintEditionDoesNotMatchMasterEditionError extends ProgramError {
  readonly name: string = 'PrintEditionDoesNotMatchMasterEdition';
  readonly code: number = 0x79; // 121
  constructor(program: Program, cause?: Error) {
    super('Print Edition does not match Master Edition', program, cause);
  }
}
codeToErrorMap.set(0x79, DasPrintEditionDoesNotMatchMasterEditionError);
nameToErrorMap.set(
  'PrintEditionDoesNotMatchMasterEdition',
  DasPrintEditionDoesNotMatchMasterEditionError
);

/**
 * EditionNumberGreaterThanMaxSupply: 'Edition Number greater than max supply'
 * @category Errors
 */
class DasEditionNumberGreaterThanMaxSupplyError extends ProgramError {
  readonly name: string = 'EditionNumberGreaterThanMaxSupply';
  readonly code: number = 0x7a; // 122
  constructor(program: Program, cause?: Error) {
    super('Edition Number greater than max supply', program, cause);
  }
}
codeToErrorMap.set(0x7a, DasEditionNumberGreaterThanMaxSupplyError);
nameToErrorMap.set(
  'EditionNumberGreaterThanMaxSupply',
  DasEditionNumberGreaterThanMaxSupplyError
);

/**
 * MustUnverify: 'Must unverify before migrating collections.'
 * @category Errors
 */
class DasMustUnverifyError extends ProgramError {
  readonly name: string = 'MustUnverify';
  readonly code: number = 0x7b; // 123
  constructor(program: Program, cause?: Error) {
    super('Must unverify before migrating collections.', program, cause);
  }
}
codeToErrorMap.set(0x7b, DasMustUnverifyError);
nameToErrorMap.set('MustUnverify', DasMustUnverifyError);

/**
 * InvalidEscrowBumpSeed: 'Invalid Escrow Account Bump Seed'
 * @category Errors
 */
class DasInvalidEscrowBumpSeedError extends ProgramError {
  readonly name: string = 'InvalidEscrowBumpSeed';
  readonly code: number = 0x7c; // 124
  constructor(program: Program, cause?: Error) {
    super('Invalid Escrow Account Bump Seed', program, cause);
  }
}
codeToErrorMap.set(0x7c, DasInvalidEscrowBumpSeedError);
nameToErrorMap.set('InvalidEscrowBumpSeed', DasInvalidEscrowBumpSeedError);

/**
 * MustBeEscrowAuthority: 'Must Escrow Authority'
 * @category Errors
 */
class DasMustBeEscrowAuthorityError extends ProgramError {
  readonly name: string = 'MustBeEscrowAuthority';
  readonly code: number = 0x7d; // 125
  constructor(program: Program, cause?: Error) {
    super('Must Escrow Authority', program, cause);
  }
}
codeToErrorMap.set(0x7d, DasMustBeEscrowAuthorityError);
nameToErrorMap.set('MustBeEscrowAuthority', DasMustBeEscrowAuthorityError);

/**
 * InvalidSystemProgram: 'Invalid System Program'
 * @category Errors
 */
class DasInvalidSystemProgramError extends ProgramError {
  readonly name: string = 'InvalidSystemProgram';
  readonly code: number = 0x7e; // 126
  constructor(program: Program, cause?: Error) {
    super('Invalid System Program', program, cause);
  }
}
codeToErrorMap.set(0x7e, DasInvalidSystemProgramError);
nameToErrorMap.set('InvalidSystemProgram', DasInvalidSystemProgramError);

/**
 * MustBeNonFungible: 'Must be a Non Fungible Token'
 * @category Errors
 */
class DasMustBeNonFungibleError extends ProgramError {
  readonly name: string = 'MustBeNonFungible';
  readonly code: number = 0x7f; // 127
  constructor(program: Program, cause?: Error) {
    super('Must be a Non Fungible Token', program, cause);
  }
}
codeToErrorMap.set(0x7f, DasMustBeNonFungibleError);
nameToErrorMap.set('MustBeNonFungible', DasMustBeNonFungibleError);

/**
 * InsufficientTokens: 'Insufficient tokens for transfer'
 * @category Errors
 */
class DasInsufficientTokensError extends ProgramError {
  readonly name: string = 'InsufficientTokens';
  readonly code: number = 0x80; // 128
  constructor(program: Program, cause?: Error) {
    super('Insufficient tokens for transfer', program, cause);
  }
}
codeToErrorMap.set(0x80, DasInsufficientTokensError);
nameToErrorMap.set('InsufficientTokens', DasInsufficientTokensError);

/**
 * BorshSerializationError: 'Borsh Serialization Error'
 * @category Errors
 */
class DasBorshSerializationErrorError extends ProgramError {
  readonly name: string = 'BorshSerializationError';
  readonly code: number = 0x81; // 129
  constructor(program: Program, cause?: Error) {
    super('Borsh Serialization Error', program, cause);
  }
}
codeToErrorMap.set(0x81, DasBorshSerializationErrorError);
nameToErrorMap.set('BorshSerializationError', DasBorshSerializationErrorError);

/**
 * NoFreezeAuthoritySet: 'Cannot create NFT with no Freeze Authority.'
 * @category Errors
 */
class DasNoFreezeAuthoritySetError extends ProgramError {
  readonly name: string = 'NoFreezeAuthoritySet';
  readonly code: number = 0x82; // 130
  constructor(program: Program, cause?: Error) {
    super('Cannot create NFT with no Freeze Authority.', program, cause);
  }
}
codeToErrorMap.set(0x82, DasNoFreezeAuthoritySetError);
nameToErrorMap.set('NoFreezeAuthoritySet', DasNoFreezeAuthoritySetError);

/**
 * InvalidCollectionSizeChange: 'Invalid collection size change'
 * @category Errors
 */
class DasInvalidCollectionSizeChangeError extends ProgramError {
  readonly name: string = 'InvalidCollectionSizeChange';
  readonly code: number = 0x83; // 131
  constructor(program: Program, cause?: Error) {
    super('Invalid collection size change', program, cause);
  }
}
codeToErrorMap.set(0x83, DasInvalidCollectionSizeChangeError);
nameToErrorMap.set(
  'InvalidCollectionSizeChange',
  DasInvalidCollectionSizeChangeError
);

/**
 * InvalidBubblegumSigner: 'Invalid bubblegum signer'
 * @category Errors
 */
class DasInvalidBubblegumSignerError extends ProgramError {
  readonly name: string = 'InvalidBubblegumSigner';
  readonly code: number = 0x84; // 132
  constructor(program: Program, cause?: Error) {
    super('Invalid bubblegum signer', program, cause);
  }
}
codeToErrorMap.set(0x84, DasInvalidBubblegumSignerError);
nameToErrorMap.set('InvalidBubblegumSigner', DasInvalidBubblegumSignerError);

/**
 * MintIsNotSigner: 'Mint needs to be signer to initialize the account'
 * @category Errors
 */
class DasMintIsNotSignerError extends ProgramError {
  readonly name: string = 'MintIsNotSigner';
  readonly code: number = 0x85; // 133
  constructor(program: Program, cause?: Error) {
    super('Mint needs to be signer to initialize the account', program, cause);
  }
}
codeToErrorMap.set(0x85, DasMintIsNotSignerError);
nameToErrorMap.set('MintIsNotSigner', DasMintIsNotSignerError);

/**
 * InvalidTokenStandard: 'Invalid token standard'
 * @category Errors
 */
class DasInvalidTokenStandardError extends ProgramError {
  readonly name: string = 'InvalidTokenStandard';
  readonly code: number = 0x86; // 134
  constructor(program: Program, cause?: Error) {
    super('Invalid token standard', program, cause);
  }
}
codeToErrorMap.set(0x86, DasInvalidTokenStandardError);
nameToErrorMap.set('InvalidTokenStandard', DasInvalidTokenStandardError);

/**
 * InvalidMintForTokenStandard: 'Invalid mint account for specified token standard'
 * @category Errors
 */
class DasInvalidMintForTokenStandardError extends ProgramError {
  readonly name: string = 'InvalidMintForTokenStandard';
  readonly code: number = 0x87; // 135
  constructor(program: Program, cause?: Error) {
    super('Invalid mint account for specified token standard', program, cause);
  }
}
codeToErrorMap.set(0x87, DasInvalidMintForTokenStandardError);
nameToErrorMap.set(
  'InvalidMintForTokenStandard',
  DasInvalidMintForTokenStandardError
);

/**
 * InvalidAuthorizationRules: 'Invalid authorization rules account'
 * @category Errors
 */
class DasInvalidAuthorizationRulesError extends ProgramError {
  readonly name: string = 'InvalidAuthorizationRules';
  readonly code: number = 0x88; // 136
  constructor(program: Program, cause?: Error) {
    super('Invalid authorization rules account', program, cause);
  }
}
codeToErrorMap.set(0x88, DasInvalidAuthorizationRulesError);
nameToErrorMap.set(
  'InvalidAuthorizationRules',
  DasInvalidAuthorizationRulesError
);

/**
 * MissingAuthorizationRules: 'Missing authorization rules account'
 * @category Errors
 */
class DasMissingAuthorizationRulesError extends ProgramError {
  readonly name: string = 'MissingAuthorizationRules';
  readonly code: number = 0x89; // 137
  constructor(program: Program, cause?: Error) {
    super('Missing authorization rules account', program, cause);
  }
}
codeToErrorMap.set(0x89, DasMissingAuthorizationRulesError);
nameToErrorMap.set(
  'MissingAuthorizationRules',
  DasMissingAuthorizationRulesError
);

/**
 * MissingProgrammableConfig: 'Missing programmable configuration'
 * @category Errors
 */
class DasMissingProgrammableConfigError extends ProgramError {
  readonly name: string = 'MissingProgrammableConfig';
  readonly code: number = 0x8a; // 138
  constructor(program: Program, cause?: Error) {
    super('Missing programmable configuration', program, cause);
  }
}
codeToErrorMap.set(0x8a, DasMissingProgrammableConfigError);
nameToErrorMap.set(
  'MissingProgrammableConfig',
  DasMissingProgrammableConfigError
);

/**
 * InvalidProgrammableConfig: 'Invalid programmable configuration'
 * @category Errors
 */
class DasInvalidProgrammableConfigError extends ProgramError {
  readonly name: string = 'InvalidProgrammableConfig';
  readonly code: number = 0x8b; // 139
  constructor(program: Program, cause?: Error) {
    super('Invalid programmable configuration', program, cause);
  }
}
codeToErrorMap.set(0x8b, DasInvalidProgrammableConfigError);
nameToErrorMap.set(
  'InvalidProgrammableConfig',
  DasInvalidProgrammableConfigError
);

/**
 * DelegateAlreadyExists: 'Delegate already exists'
 * @category Errors
 */
class DasDelegateAlreadyExistsError extends ProgramError {
  readonly name: string = 'DelegateAlreadyExists';
  readonly code: number = 0x8c; // 140
  constructor(program: Program, cause?: Error) {
    super('Delegate already exists', program, cause);
  }
}
codeToErrorMap.set(0x8c, DasDelegateAlreadyExistsError);
nameToErrorMap.set('DelegateAlreadyExists', DasDelegateAlreadyExistsError);

/**
 * DelegateNotFound: 'Delegate not found'
 * @category Errors
 */
class DasDelegateNotFoundError extends ProgramError {
  readonly name: string = 'DelegateNotFound';
  readonly code: number = 0x8d; // 141
  constructor(program: Program, cause?: Error) {
    super('Delegate not found', program, cause);
  }
}
codeToErrorMap.set(0x8d, DasDelegateNotFoundError);
nameToErrorMap.set('DelegateNotFound', DasDelegateNotFoundError);

/**
 * MissingAccountInBuilder: 'Required account not set in instruction builder'
 * @category Errors
 */
class DasMissingAccountInBuilderError extends ProgramError {
  readonly name: string = 'MissingAccountInBuilder';
  readonly code: number = 0x8e; // 142
  constructor(program: Program, cause?: Error) {
    super('Required account not set in instruction builder', program, cause);
  }
}
codeToErrorMap.set(0x8e, DasMissingAccountInBuilderError);
nameToErrorMap.set('MissingAccountInBuilder', DasMissingAccountInBuilderError);

/**
 * MissingArgumentInBuilder: 'Required argument not set in instruction builder'
 * @category Errors
 */
class DasMissingArgumentInBuilderError extends ProgramError {
  readonly name: string = 'MissingArgumentInBuilder';
  readonly code: number = 0x8f; // 143
  constructor(program: Program, cause?: Error) {
    super('Required argument not set in instruction builder', program, cause);
  }
}
codeToErrorMap.set(0x8f, DasMissingArgumentInBuilderError);
nameToErrorMap.set(
  'MissingArgumentInBuilder',
  DasMissingArgumentInBuilderError
);

/**
 * FeatureNotSupported: 'Feature not supported currently'
 * @category Errors
 */
class DasFeatureNotSupportedError extends ProgramError {
  readonly name: string = 'FeatureNotSupported';
  readonly code: number = 0x90; // 144
  constructor(program: Program, cause?: Error) {
    super('Feature not supported currently', program, cause);
  }
}
codeToErrorMap.set(0x90, DasFeatureNotSupportedError);
nameToErrorMap.set('FeatureNotSupported', DasFeatureNotSupportedError);

/**
 * InvalidSystemWallet: 'Invalid system wallet'
 * @category Errors
 */
class DasInvalidSystemWalletError extends ProgramError {
  readonly name: string = 'InvalidSystemWallet';
  readonly code: number = 0x91; // 145
  constructor(program: Program, cause?: Error) {
    super('Invalid system wallet', program, cause);
  }
}
codeToErrorMap.set(0x91, DasInvalidSystemWalletError);
nameToErrorMap.set('InvalidSystemWallet', DasInvalidSystemWalletError);

/**
 * OnlySaleDelegateCanTransfer: 'Only the sale delegate can transfer while its set'
 * @category Errors
 */
class DasOnlySaleDelegateCanTransferError extends ProgramError {
  readonly name: string = 'OnlySaleDelegateCanTransfer';
  readonly code: number = 0x92; // 146
  constructor(program: Program, cause?: Error) {
    super('Only the sale delegate can transfer while its set', program, cause);
  }
}
codeToErrorMap.set(0x92, DasOnlySaleDelegateCanTransferError);
nameToErrorMap.set(
  'OnlySaleDelegateCanTransfer',
  DasOnlySaleDelegateCanTransferError
);

/**
 * MissingTokenAccount: 'Missing token account'
 * @category Errors
 */
class DasMissingTokenAccountError extends ProgramError {
  readonly name: string = 'MissingTokenAccount';
  readonly code: number = 0x93; // 147
  constructor(program: Program, cause?: Error) {
    super('Missing token account', program, cause);
  }
}
codeToErrorMap.set(0x93, DasMissingTokenAccountError);
nameToErrorMap.set('MissingTokenAccount', DasMissingTokenAccountError);

/**
 * MissingSplTokenProgram: 'Missing SPL token program'
 * @category Errors
 */
class DasMissingSplTokenProgramError extends ProgramError {
  readonly name: string = 'MissingSplTokenProgram';
  readonly code: number = 0x94; // 148
  constructor(program: Program, cause?: Error) {
    super('Missing SPL token program', program, cause);
  }
}
codeToErrorMap.set(0x94, DasMissingSplTokenProgramError);
nameToErrorMap.set('MissingSplTokenProgram', DasMissingSplTokenProgramError);

/**
 * MissingAuthorizationRulesProgram: 'Missing SPL token program'
 * @category Errors
 */
class DasMissingAuthorizationRulesProgramError extends ProgramError {
  readonly name: string = 'MissingAuthorizationRulesProgram';
  readonly code: number = 0x95; // 149
  constructor(program: Program, cause?: Error) {
    super('Missing SPL token program', program, cause);
  }
}
codeToErrorMap.set(0x95, DasMissingAuthorizationRulesProgramError);
nameToErrorMap.set(
  'MissingAuthorizationRulesProgram',
  DasMissingAuthorizationRulesProgramError
);

/**
 * InvalidDelegateRoleForTransfer: 'Invalid delegate role for transfer'
 * @category Errors
 */
class DasInvalidDelegateRoleForTransferError extends ProgramError {
  readonly name: string = 'InvalidDelegateRoleForTransfer';
  readonly code: number = 0x96; // 150
  constructor(program: Program, cause?: Error) {
    super('Invalid delegate role for transfer', program, cause);
  }
}
codeToErrorMap.set(0x96, DasInvalidDelegateRoleForTransferError);
nameToErrorMap.set(
  'InvalidDelegateRoleForTransfer',
  DasInvalidDelegateRoleForTransferError
);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export function getMplDigitalAssetErrorFromCode(
  code: number,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = codeToErrorMap.get(code);
  return constructor ? new constructor(program, cause) : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export function getMplDigitalAssetErrorFromName(
  name: string,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = nameToErrorMap.get(name);
  return constructor ? new constructor(program, cause) : null;
}
